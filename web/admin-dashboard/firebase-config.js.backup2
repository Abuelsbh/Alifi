// Firebase Configuration
const firebaseConfig = {
    apiKey: "AIzaSyDrzOlXjtKLa-xsY--c3ijkMbejVJcGIwM",
    authDomain: "bookingplayground-3f74b.firebaseapp.com",
    projectId: "bookingplayground-3f74b",
    storageBucket: "bookingplayground-3f74b.appspot.com",
    messagingSenderId: "470661629842",
    appId: "1:470661629842:android:acba6cbfd1a488abc3e34b"
};

// Initialize Firebase
firebase.initializeApp(firebaseConfig);

// Initialize Firebase services
const auth = firebase.auth();
const db = firebase.firestore();

// Firebase helper functions
const FirebaseService = {
    // Authentication
    async signIn(email, password) {
        try {
            const result = await auth.signInWithEmailAndPassword(email, password);
            return { success: true, user: result.user };
        } catch (error) {
            return { success: false, error: error.message };
        }
    },

    async signOut() {
        try {
            await auth.signOut();
            return { success: true };
        } catch (error) {
            return { success: false, error: error.message };
        }
    },

    // Get current user
    getCurrentUser() {
        return auth.currentUser;
    },

    // Listen to auth state changes
    onAuthStateChanged(callback) {
        return auth.onAuthStateChanged(callback);
    },

    // Check if user is admin from Firestore
    async checkAdminStatus(userId) {
        try {
            const userDoc = await db.collection('users').doc(userId).get();
            if (userDoc.exists) {
                const userData = userDoc.data();
                return userData.customClaims && userData.customClaims.admin === true;
            }
            return false;
        } catch (error) {
            console.error('Error checking admin status:', error);
            return false;
        }
    },

    // Veterinarians CRUD operations
    async getVeterinarians() {
        try {
            const snapshot = await db.collection('veterinarians')
                .orderBy('createdAt', 'desc')
                .get();
            
            const vets = [];
            snapshot.forEach(doc => {
                vets.push({
                    id: doc.id,
                    ...doc.data()
                });
            });
            
            return { success: true, data: vets };
        } catch (error) {
            console.error('Error getting veterinarians:', error);
            return { success: false, error: error.message };
        }
    },

    // Listen to veterinarians in real-time
    onVeterinariansChange(callback) {
        return db.collection('veterinarians')
            .orderBy('createdAt', 'desc')
            .onSnapshot(snapshot => {
                const vets = [];
                snapshot.forEach(doc => {
                    vets.push({
                        id: doc.id,
                        ...doc.data()
                    });
                });
                callback(vets);
            });
    },

    async createVeterinarian(vetData) {
        try {
            // Create user account first
            const userCredential = await auth.createUserWithEmailAndPassword(
                vetData.email, 
                vetData.password
            );
            
            const uid = userCredential.user.uid;
            
            // Create veterinarian document
            await db.collection('veterinarians').doc(uid).set({
                uid: uid,
                name: vetData.name,
                email: vetData.email,
                phone: vetData.phone,
                specialization: vetData.specialization,
                experience: vetData.experience,
                license: vetData.license || '',
                isActive: true,
                isOnline: false,
                rating: 0.0,
                totalRatings: 0,
                isVerified: true,
                userType: 'veterinarian',
                createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
                joinDate: new Date().toISOString()
            });

            // Update display name
            await userCredential.user.updateProfile({
                displayName: vetData.name
            });

            return { success: true, id: uid };
        } catch (error) {
            console.error('Error creating veterinarian:', error);
            return { success: false, error: error.message };
        }
    },

    async updateVeterinarian(vetId, vetData) {
        try {
            await db.collection('veterinarians').doc(vetId).update({
                name: vetData.name,
                email: vetData.email,
                phone: vetData.phone,
                specialization: vetData.specialization,
                experience: vetData.experience,
                license: vetData.license || '',
                updatedAt: firebase.firestore.FieldValue.serverTimestamp()
            });

            return { success: true };
        } catch (error) {
            console.error('Error updating veterinarian:', error);
            return { success: false, error: error.message };
        }
    },

    async toggleVeterinarianStatus(vetId, isActive) {
        try {
            await db.collection('veterinarians').doc(vetId).update({
                isActive: isActive,
                updatedAt: firebase.firestore.FieldValue.serverTimestamp()
            });

            return { success: true };
        } catch (error) {
            console.error('Error toggling veterinarian status:', error);
            return { success: false, error: error.message };
        }
    },

    async deleteVeterinarian(vetId) {
        try {
            await db.collection('veterinarians').doc(vetId).delete();
            return { success: true };
        } catch (error) {
            console.error('Error deleting veterinarian:', error);
            return { success: false, error: error.message };
        }
    },

    // Get statistics
    async getStats() {
        try {
            const stats = {
                totalVets: 0,
                totalUsers: 0,
                activeUsers: 0,
                totalStores: 0,
                activeStores: 0,
                totalReports: 0,
                pendingReports: 0,
                totalChats: 0
            };

            // Get veterinarians count
            const vetsSnapshot = await db.collection('veterinarians').get();
            stats.totalVets = vetsSnapshot.size;

            // Get users count and active users
            const usersSnapshot = await db.collection('users').get();
            stats.totalUsers = usersSnapshot.size;
            stats.activeUsers = usersSnapshot.docs.filter(doc => {
                const data = doc.data();
                return data.status !== 'banned';
            }).length;

            // Get stores count and active stores
            const storesSnapshot = await db.collection('petStores').get();
            stats.totalStores = storesSnapshot.size;
            stats.activeStores = storesSnapshot.docs.filter(doc => {
                const data = doc.data();
                return data.isActive === true;
            }).length;

            // Get reports count from all collections
            const reportCollections = ['lost_pets', 'found_pets', 'adoption_pets', 'breeding_pets'];
            let totalReports = 0;
            let pendingReports = 0;
            
            for (const collection of reportCollections) {
                try {
                    const snapshot = await db.collection(collection).get();
                    totalReports += snapshot.size;
                    
                    // Count pending reports
                    const pendingSnapshot = await db.collection(collection)
                        .where('status', 'in', ['pending', 'active'])
                        .get();
                    pendingReports += pendingSnapshot.size;
                } catch (error) {
                    console.warn(`Collection ${collection} not accessible:`, error.message);
                }
            }
            
            stats.totalReports = totalReports;
            stats.pendingReports = pendingReports;

            // Get chats count (mock data for now)
            stats.totalChats = Math.floor(Math.random() * 50) + 10;

            return { success: true, data: stats };
        } catch (error) {
            console.error('Error getting stats:', error);
            return { success: false, error: error.message, data: {
                totalVets: 0,
                totalUsers: 0,
                activeUsers: 0,
                totalStores: 0,
                activeStores: 0,
                totalReports: 0,
                pendingReports: 0,
                totalChats: 0
            }};
        }
    },

    // Pet Stores CRUD operations
    async getPetStores() {
        try {
            const snapshot = await db.collection('petStores')
                .orderBy('createdAt', 'desc')
                .get();
            
            const stores = [];
            snapshot.forEach(doc => {
                stores.push({
                    id: doc.id,
                    ...doc.data()
                });
            });
            
            return { success: true, data: stores };
        } catch (error) {
            console.error('Error getting pet stores:', error);
            return { success: false, error: error.message };
        }
    },

    // Listen to pet stores in real-time
    onPetStoresChange(callback) {
        return db.collection('petStores')
            .orderBy('createdAt', 'desc')
            .onSnapshot(snapshot => {
                const stores = [];
                snapshot.forEach(doc => {
                    stores.push({
                        id: doc.id,
                        ...doc.data()
                    });
                });
                callback(stores);
            });
    },

    async createPetStore(storeData) {
        try {
            const docRef = await db.collection('petStores').add({
                name: storeData.name,
                category: storeData.category,
                phone: storeData.phone,
                email: storeData.email || '',
                address: storeData.address,
                city: storeData.city,
                website: storeData.website || '',
                workingHours: storeData.workingHours || '',
                deliveryAvailable: storeData.deliveryAvailable === 'true',
                description: storeData.description || '',
                imageUrl: storeData.imageUrl || '',
                rating: parseFloat(storeData.rating) || 4.0,
                isActive: true,
                createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                updatedAt: firebase.firestore.FieldValue.serverTimestamp()
            });

            console.log('Advertisement created successfully with ID:', docRef.id);
            return { success: true, id: docRef.id };
        } catch (error) {
            console.error('Error creating pet store:', error);
            return { success: false, error: error.message };
        }
    },

    async updatePetStore(storeId, storeData) {
        try {
            await db.collection('petStores').doc(storeId).update({
                name: storeData.name,
                category: storeData.category,
                phone: storeData.phone,
                email: storeData.email || '',
                address: storeData.address,
                city: storeData.city,
                website: storeData.website || '',
                workingHours: storeData.workingHours || '',
                deliveryAvailable: storeData.deliveryAvailable === 'true',
                description: storeData.description || '',
                imageUrl: storeData.imageUrl || '',
                rating: parseFloat(storeData.rating) || 4.0,
                updatedAt: firebase.firestore.FieldValue.serverTimestamp()
            });

            return { success: true };
        } catch (error) {
            console.error('Error updating pet store:', error);
            return { success: false, error: error.message };
        }
    },

    async togglePetStoreStatus(storeId, isActive) {
        try {
            await db.collection('petStores').doc(storeId).update({
                isActive: isActive,
                updatedAt: firebase.firestore.FieldValue.serverTimestamp()
            });

            return { success: true };
        } catch (error) {
            console.error('Error toggling pet store status:', error);
            return { success: false, error: error.message };
        }
    },

    async deletePetStore(storeId) {
        try {
            await db.collection('petStores').doc(storeId).delete();
            return { success: true };
        } catch (error) {
            console.error('Error deleting pet store:', error);
            return { success: false, error: error.message };
        }
    },

    // Get recent activity
    async getRecentActivity() {
        try {
            const activities = [];
            
            // Get recent veterinarians
            const vetsSnapshot = await db.collection('veterinarians')
                .orderBy('createdAt', 'desc')
                .limit(3)
                .get();
            
            vetsSnapshot.forEach(doc => {
                const data = doc.data();
                activities.push({
                    type: 'new',
                    title: `New veterinarian: ${data.name}`,
                    description: `Added ${data.specialization} specialist`,
                    timestamp: data.createdAt
                });
            });

            // Get recent pet stores
            const storesSnapshot = await db.collection('petStores')
                .orderBy('createdAt', 'desc')
                .limit(3)
                .get();
            
            storesSnapshot.forEach(doc => {
                const data = doc.data();
                activities.push({
                    type: 'new',
                    title: `New pet store: ${data.name}`,
                    description: `Added ${data.category} store in ${data.city}`,
                    timestamp: data.createdAt
                });
            });

            // Sort by timestamp
            activities.sort((a, b) => {
                if (!a.timestamp || !b.timestamp) return 0;
                return b.timestamp.toDate() - a.timestamp.toDate();
            });

            return { success: true, data: activities.slice(0, 5) };
        } catch (error) {
            console.error('Error getting recent activity:', error);
            return { success: false, error: error.message, data: [] };
        }
    },

    // Users Management Functions
    async getUsers() {
        try {
            const snapshot = await db.collection('users')
                .orderBy('createdAt', 'desc')
                .get();
            
            const users = [];
            snapshot.forEach(doc => {
                const data = doc.data();
                users.push({
                    id: doc.id,
                    ...data,
                    createdAt: data.createdAt?.toDate() || new Date(),
                    lastActive: data.lastActive?.toDate() || null
                });
            });
            
            return users;
        } catch (error) {
            console.error('Error fetching users:', error);
            return [];
        }
    },

    async getUserById(userId) {
        try {
            const doc = await db.collection('users').doc(userId).get();
            if (doc.exists) {
                const data = doc.data();
                return {
                    id: doc.id,
                    ...data,
                    createdAt: data.createdAt?.toDate() || new Date(),
                    lastActive: data.lastActive?.toDate() || null
                };
            }
            return null;
        } catch (error) {
            console.error('Error fetching user:', error);
            return null;
        }
    },

    async banUser(userId) {
        try {
            await db.collection('users').doc(userId).update({
                status: 'banned',
                bannedAt: firebase.firestore.FieldValue.serverTimestamp(),
                updatedAt: firebase.firestore.FieldValue.serverTimestamp()
            });
            console.log('User banned successfully');
            return { success: true };
        } catch (error) {
            console.error('Error banning user:', error);
            return { success: false, error: error.message };
        }
    },

    async unbanUser(userId) {
        try {
            await db.collection('users').doc(userId).update({
                status: 'active',
                bannedAt: firebase.firestore.FieldValue.delete(),
                updatedAt: firebase.firestore.FieldValue.serverTimestamp()
            });
            console.log('User unbanned successfully');
            return { success: true };
        } catch (error) {
            console.error('Error unbanning user:', error);
            return { success: false, error: error.message };
        }
    },

    // Admins Management Functions (New Section)
    async getAdmins() {
        try {
            // In a real application, fetching users by custom claims should be done server-side
            // For client-side demo, we'll fetch all users and filter by custom claim locally (less efficient)
            const usersSnapshot = await db.collection('users').get();
            const admins = [];
            for (const doc of usersSnapshot.docs) {
                const userData = doc.data();
                // Check for custom claim (this client-side check is illustrative, rely on backend for robust auth)
                if (userData.customClaims && userData.customClaims.admin === true) {
                    admins.push({
                        id: doc.id,
                        uid: doc.id, // Assuming doc.id is the UID
                        name: userData.name || userData.email,
                        email: userData.email,
                        lastSignInTime: userData.lastSignInTime?.toDate() || null
                    });
                }
            }
            return admins;
        } catch (error) {
            console.error('Error fetching admins:', error);
            return [];
        }
    },

    async createAdmin(email, password, displayName) {
        // WARNING: Setting custom claims from client-side is INSECURE for production apps.
        // This should be done via a Firebase Cloud Function or other secure backend service
        // using the Firebase Admin SDK.
        try {
            const userCredential = await auth.createUserWithEmailAndPassword(email, password);
            const uid = userCredential.user.uid;

            // Set custom claim (insecure client-side example)
            // For a secure implementation, call a Cloud Function here:
            // await firebase.functions().httpsCallable('addAdminRole')({ email: email });
            await userCredential.user.getIdToken(true); // Refresh token to get new claims
            // This part where custom claims are directly set client-side is a placeholder and WILL NOT WORK
            // You need a backend call to set custom claims. This mock is for UI integration.
            await db.collection('users').doc(uid).set({
                email: email,
                name: displayName,
                customClaims: { admin: true },
                createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                lastSignInTime: firebase.firestore.FieldValue.serverTimestamp()
            }, { merge: true });
            
            return { success: true, uid: uid };
        } catch (error) {
            console.error('Error creating admin:', error);
            return { success: false, error: error.message };
        }
    },

    async removeAdmin(uid) {
        // WARNING: Removing custom claims and deleting users from client-side is INSECURE for production apps.
        // This should be done via a Firebase Cloud Function or other secure backend service
        // using the Firebase Admin SDK.
        try {
            // Remove custom claim (insecure client-side example)
            // For a secure implementation, call a Cloud Function here:
            // await firebase.functions().httpsCallable('removeAdminRole')({ uid: uid });
            await db.collection('users').doc(uid).update({
                'customClaims.admin': firebase.firestore.FieldValue.delete(),
                updatedAt: firebase.firestore.FieldValue.serverTimestamp()
            });

            // Delete user from authentication
            // Note: Client-side delete only works for the currently signed-in user.
            // To delete other users, you NEED the Admin SDK on a backend.
            // await auth.currentUser.delete(); // This would delete the currently logged in admin!

            // For demonstration, we will just update the Firestore record for the user
            // In a real app, a Cloud Function would delete the Auth user.
            console.warn('Client-side admin removal is incomplete. Implement a Cloud Function for full security.');
            
            return { success: true };
        } catch (error) {
            console.error('Error removing admin:', error);
            return { success: false, error: error.message };
        }
    },

    // Reports Management Functions
    async getReports() {
        try {
            const collections = ['lost_pets', 'found_pets', 'adoption_pets', 'breeding_pets'];
            const reports = [];
            
            for (const collectionName of collections) {
                const snapshot = await db.collection(collectionName)
                    .limit(50)
                    .get();
                
                snapshot.forEach(doc => {
                    const data = doc.data();
                    reports.push({
                        id: doc.id,
                        collection: collectionName,
                        type: collectionName.replace('_pets', ''),
                        ...data,
                        createdAt: data.createdAt?.toDate() || new Date(),
                        updatedAt: data.updatedAt?.toDate() || null
                    });
                });
            }
            
            // Sort by creation date
            reports.sort((a, b) => b.createdAt - a.createdAt);
            return reports;
        } catch (error) {
            console.error('Error fetching reports:', error);
            return [];
        }
    },

    async getReportById(reportId, collection) {
        try {
            const doc = await db.collection(collection).doc(reportId).get();
            if (doc.exists) {
                const data = doc.data();
                return {
                    id: doc.id,
                    collection: collection,
                    type: collection.replace('_pets', ''),
                    ...data,
                    createdAt: data.createdAt?.toDate() || new Date(),
                    updatedAt: data.updatedAt?.toDate() || null
                };
            }
            return null;
        } catch (error) {
            console.error('Error fetching report:', error);
            return null;
        }
    },

    async approveReport(reportId, collection) {
        try {
            await db.collection(collection).doc(reportId).update({
                status: 'approved',
                approvedAt: firebase.firestore.FieldValue.serverTimestamp(),
                updatedAt: firebase.firestore.FieldValue.serverTimestamp()
            });
            console.log('Report approved successfully');
            return { success: true };
        } catch (error) {
            console.error('Error approving report:', error);
            return { success: false, error: error.message };
        }
    },

    async rejectReport(reportId, collection) {
        try {
            await db.collection(collection).doc(reportId).update({
                status: 'rejected',
                rejectedAt: firebase.firestore.FieldValue.serverTimestamp(),
                updatedAt: firebase.firestore.FieldValue.serverTimestamp()
            });
            console.log('Report rejected successfully');
            return { success: true };
        } catch (error) {
            console.error('Error rejecting report:', error);
            return { success: false, error: error.message };
        }
    },

    // Settings Management Functions
    async getSettings() {
        try {
            const doc = await db.collection('settings').doc('app').get();
            if (doc.exists) {
                return { success: true, data: doc.data() };
            }
            return { success: true, data: this.getDefaultSettings() };
        } catch (error) {
            console.error('Error fetching settings:', error);
            return { success: false, error: error.message, data: this.getDefaultSettings() };
        }
    },

    async saveSettings(settings) {
        try {
            await db.collection('settings').doc('app').set({
                ...settings,
                updatedAt: firebase.firestore.FieldValue.serverTimestamp()
            }, { merge: true });
            console.log('Settings saved successfully');
            return { success: true };
        } catch (error) {
            console.error('Error saving settings:', error);
            return { success: false, error: error.message };
        }
    },

    getDefaultSettings() {
        return {
            appName: 'Alifi - Pet Care Platform',
            appDescription: 'A comprehensive platform for pet care, adoption, and veterinary services.',
            maintenanceMode: false,
            emailNotifications: true,
            pushNotifications: true,
            adminEmail: 'admin3@alifi.com',
            autoApproveReports: false,
            maxImagesPerReport: 5,
            reportExpiryDays: 30
        };
    },

    // Admin Messages Functions
    async sendMessageToUser(userId, messageData) {
        try {
            // Create message document
            const messageDoc = {
                userId: userId,
                subject: messageData.subject,
                content: messageData.content,
                type: messageData.type || 'info',
                isRead: false,
                isAdminMessage: true,
                createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                updatedAt: firebase.firestore.FieldValue.serverTimestamp()
            };

            // Add to admin_messages collection
            const docRef = await db.collection('admin_messages').add(messageDoc);
            
            // Also add to user's notifications
            await db.collection('users').doc(userId).collection('notifications').add({
                ...messageDoc,
                messageId: docRef.id,
                notificationType: 'admin_message'
            });

            console.log('Message sent successfully');
            return { success: true, messageId: docRef.id };
        } catch (error) {
            console.error('Error sending message:', error);
            return { success: false, error: error.message };
        }
    },

    async getAdminMessages() {
        try {
            const snapshot = await db.collection('admin_messages')
                .orderBy('createdAt', 'desc')
                .get();
            
            const messages = [];
            snapshot.forEach(doc => {
                const data = doc.data();
                messages.push({
                    id: doc.id,
                    ...data,
                    createdAt: data.createdAt?.toDate() || new Date(),
                    updatedAt: data.updatedAt?.toDate() || null
                });
            });
            
            return messages;
        } catch (error) {
            console.error('Error fetching admin messages:', error);
            return [];
        }
    },

    async getUserMessages(userId) {
        try {
            const snapshot = await db.collection('admin_messages')
                .where('userId', '==', userId)
                .orderBy('createdAt', 'desc')
                .get();
            
            const messages = [];
            snapshot.forEach(doc => {
                const data = doc.data();
                messages.push({
                    id: doc.id,
                    ...data,
                    createdAt: data.createdAt?.toDate() || new Date(),
                    updatedAt: data.updatedAt?.toDate() || null
                });
            });
            
            return messages;
        } catch (error) {
            console.error('Error fetching user messages:', error);
            return [];
        }
    },

    async markMessageAsRead(messageId) {
        try {
            await db.collection('admin_messages').doc(messageId).update({
                isRead: true,
                readAt: firebase.firestore.FieldValue.serverTimestamp(),
                updatedAt: firebase.firestore.FieldValue.serverTimestamp()
            });
            console.log('Message marked as read');
            return { success: true };
        } catch (error) {
            console.error('Error marking message as read:', error);
            return { success: false, error: error.message };
        }
    },

    // Advertisements Management Functions
    async getAds() {
        try {
            const snapshot = await db.collection('advertisements')
                .where('isActive', '==', true)
                .orderBy('displayOrder', 'asc')
                .limit(10)
                .get();
            
            const ads = [];
            snapshot.forEach(doc => {
                const data = doc.data();
                ads.push({
                    id: doc.id,
                    ...data,
                    createdAt: data.createdAt?.toDate() || new Date(),
                    updatedAt: data.updatedAt?.toDate() || null
                });
            });
            
            return { success: true, data: ads };
        } catch (error) {
            console.error('Error getting ads:', error);
            return { success: false, error: error.message, data: [] };
        }
    },

    async getAllAds() {
        try {
            const snapshot = await db.collection('advertisements')
                .orderBy('createdAt', 'desc')
                .get();
            
            const ads = [];
            snapshot.forEach(doc => {
                const data = doc.data();
                ads.push({
                    id: doc.id,
                    ...data,
                    createdAt: data.createdAt?.toDate() || new Date(),
                    updatedAt: data.updatedAt?.toDate() || null
                });
            });
            
            return { success: true, data: ads };
        } catch (error) {
            console.error('Error getting all ads:', error);
            return { success: false, error: error.message, data: [] };
        }
    },

    async createAd(adData) {
        console.log('createAd called with data:', adData);
        try {
            // Check if we already have 10 ads
            const adsCount = await db.collection('advertisements').get();
            if (adsCount.size >= 10) {
                return { success: false, error: 'Maximum of 10 advertisements allowed' };
            }

            console.log('Adding document to advertisements collection...');
            const docRef = await db.collection('advertisements').add({
                title: adData.title || '',
                description: adData.description || '',
                imageUrl: adData.imageUrl,
                displayOrder: parseInt(adData.displayOrder) || 1,
                isActive: adData.isActive !== false,
                clickUrl: adData.clickUrl || '',
                clickCount: 0,
                views: 0,
                createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                updatedAt: firebase.firestore.FieldValue.serverTimestamp()
            });

            console.log('Advertisement created successfully with ID:', docRef.id);
            return { success: true, id: docRef.id };
        } catch (error) {
            console.error('Error creating ad:', error);
            return { success: false, error: error.message };
        }
    },

    async updateAd(adId, adData) {
        try {
            await db.collection('advertisements').doc(adId).update({
                title: adData.title || '',
                description: adData.description || '',
                imageUrl: adData.imageUrl,
                displayOrder: parseInt(adData.displayOrder) || 1,
                isActive: adData.isActive !== false,
                clickUrl: adData.clickUrl || '',
                updatedAt: firebase.firestore.FieldValue.serverTimestamp()
            });

            return { success: true };
        } catch (error) {
            console.error('Error updating ad:', error);
            return { success: false, error: error.message };
        }
    },

    async toggleAdStatus(adId, isActive) {
        try {
            await db.collection('advertisements').doc(adId).update({
                isActive: isActive,
                updatedAt: firebase.firestore.FieldValue.serverTimestamp()
            });

            return { success: true };
        } catch (error) {
            console.error('Error toggling ad status:', error);
            return { success: false, error: error.message };
        }
    },

    async deleteAd(adId) {
        try {
            await db.collection('advertisements').doc(adId).delete();
            return { success: true };
        } catch (error) {
            console.error('Error deleting ad:', error);
            return { success: false, error: error.message };
        }
    },

    async incrementAdView(adId) {
        try {
            await db.collection('advertisements').doc(adId).update({
                views: firebase.firestore.FieldValue.increment(1)
            });
        } catch (error) {
            console.error('Error incrementing ad view:', error);
        }
    },

    async incrementAdClick(adId) {
        try {
            await db.collection('advertisements').doc(adId).update({
                clickCount: firebase.firestore.FieldValue.increment(1)
            });
        } catch (error) {
            console.error('Error incrementing ad click:', error);
        }
    }
};

// Export for use in other files
window.FirebaseService = FirebaseService; 